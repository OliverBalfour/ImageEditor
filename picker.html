<!DOCTYPE html>
<html>
<head>
	<title>Colour Picker 2.0</title>
	<meta charset="utf-8">
	<style type="text/css">canvas{border:1px solid black}</style>
</head>
<body>
<div class='picker'></div>
<span>Hello</span>
<script src='tinycolor/tinycolor.js'></script>
<script>
function ColourPicker (onUpdate, width, height) {
	this.canvas = document.createElement('canvas');
	this.ctx = this.canvas.getContext('2d');
	this.onUpdate = onUpdate;

	this.canvas.width = !isNaN(width) && width > 0 ? Math.round(width) : 128;
	this.canvas.height = !isNaN(height) && height > 0 ? Math.round(height) : this.canvas.width;

	this.hueCircleWidth = Math.min(this.canvas.width, this.canvas.height) / 8;

	this.mouse = { x: 0, y: 0 };
	// dragging: 'none', 'hue', or 'triangle'
	this.dragging = 'none';

	// hue, 0-360, on the hue circle
	this.hue = 0;
	// x,y point (0-1 scaled across width) on the saturation/lightness triangle
	// indicated by small black/white circle
	this.point = {x: 0.5, y: 0}
	this.selectedColour = tinycolor({h: 0, s: 0, l: 0, a: 0});
	this.transparentBlack = tinycolor({h: 0, s: 0, l: 0, a: 0});

	this.imageDataCache = null;
	this.updateImageDataCache = () => this.imageDataCache = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

	this.getColour = () => {
		let m = this.getMeasurements(),
			x = m.leftX + this.point.x * m.triangleSideLength,
			y = m.topY + this.point.y * (1.5 * m.triangleRadius);

		let i = 4 * (y * this.canvas.width + x);

		return tinycolor({
			r: this.imageDataCache.data[i],
			g: this.imageDataCache.data[i + 1],
			b: this.imageDataCache.data[i + 2],
			a: this.imageDataCache.data[i + 3]
		});
	}

	this.updateMouseCoords = event => {
		this.box = this.canvas.getBoundingClientRect();
		this.mouse.x = event.clientX - this.box.left;
		this.mouse.y = event.clientY - this.box.top;
	}

	this.getMeasurements = () => {
		let w = this.canvas.width,
			h = this.canvas.height,
			// smaller and larger dimension
			min = Math.min(w, h),
			max = Math.max(w, h),
			// margin on either side of colour picker
			mx = h < w ? Math.floor((max - min) / 2) : 0,
			my = w < h ? Math.floor((max - min) / 2) : 0,
			hueCircleWidth = this.hueCircleWidth,
			// distance from corner to center of triangle
			// not technically a radius, there's another word for it which I've forgotten
			triangleRadius = Math.floor(min / 2) - hueCircleWidth,
			// `sqrt(3) / 2 * radius` is half the side length of the triangle
			triangleSideLength = Math.sqrt(3) * triangleRadius,
			leftX = w / 2 - triangleSideLength / 2,
			rightX = w / 2 + triangleSideLength / 2,
			topY = my + hueCircleWidth,
			bottomY = (h + triangleRadius) / 2;

		return {
			w, h, min, max, mx, my,
			hueCircleWidth, triangleRadius, triangleSideLength,
			leftX, rightX, topY, bottomY
		};
	}

	this.mouseInsideTriangle = () => {
		let m = this.getMeasurements();

		// if mouse is below bottom of triangle, or too far left or right to possibly collide
		// ie bounding box collision detection
		if (
			this.mouse.y > m.bottomY ||
			this.mouse.x < m.leftX ||
			this.mouse.x > m.rightX ||
			this.mouse.y < m.topY
		)
			return false;

		// if the angle from the right bottom corner to the mouse is > 60 degrees
		if (Math.atan(
			(this.mouse.y - m.bottomY)
			/ (this.mouse.x - m.rightX)
		) / Math.PI * 180 > 60)
			return false;

		// if the angle from the left bottom corner to the mouse is > 60 degrees
		if (Math.atan(
			(this.mouse.y - m.bottomY)
			/ (this.mouse.x - m.leftX)
		) / Math.PI * 180 < -60)
			return false;

		return true;
	}

	this.draw = () => {
		this.drawCircle();
		this.drawTriangle();
	}

	this.drawCircle = () => {
		let m = this.getMeasurements(),
			segments = m.max * 4;

		this.ctx.lineWidth = m.hueCircleWidth;

		// draw circle; composed of a few hundred small stroked arcs of different colours
		for (let i = 0; i <= 2 * Math.PI; i += Math.PI / segments) {
			this.ctx.strokeStyle = tinycolor({ h: i / Math.PI * 180, s: 100, l: 50 }).toHslString();
			this.ctx.beginPath();
			this.ctx.arc(
				Math.floor(m.w / 2), Math.floor(m.h / 2),
				Math.floor(m.min / 2) - m.hueCircleWidth / 2,
				i, i + Math.PI / segments + 0.01
			);
			this.ctx.stroke();
			this.ctx.closePath();
		}

		// draw indicator
		let theta = this.hue / 180 * Math.PI;
		this.ctx.strokeStyle = 'black';
		this.ctx.lineWidth = 1;
		this.ctx.beginPath();
		this.ctx.moveTo(
			Math.cos(theta) * m.triangleRadius + m.w / 2,
			Math.sin(theta) * m.triangleRadius + m.h / 2
		);
		this.ctx.lineTo(
			Math.cos(theta) * (m.triangleRadius + m.hueCircleWidth) + m.w / 2,
			Math.sin(theta) * (m.triangleRadius + m.hueCircleWidth) + m.h / 2
		);
		this.ctx.stroke();

		this.updateImageDataCache();
	}

	this.drawTriangle = () => {
		let m = this.getMeasurements();

		const fillTriangle = fill => {
			this.ctx.fillStyle = fill;
			this.ctx.beginPath();
			this.ctx.moveTo(m.w / 2, m.topY);
			this.ctx.lineTo(m.leftX, m.bottomY);
			this.ctx.lineTo(m.rightX, m.bottomY);
			this.ctx.fill();
			this.ctx.closePath();
		}

		// clear old triangle
		this.ctx.fillStyle = '#ccc';
		this.ctx.beginPath();
		this.ctx.arc(m.w / 2, m.h / 2, m.triangleRadius, 0, Math.PI * 2);
		this.ctx.fill();
		this.ctx.closePath();

		// draw saturation gradient
		const saturationGradient = this.ctx.createLinearGradient(
			m.leftX, 0,
			m.rightX, 0
		);
		saturationGradient.addColorStop(0, 'white');
		saturationGradient.addColorStop(1, tinycolor({ h: this.hue, s: 100, l: 50 }).toHslString());
		fillTriangle(saturationGradient);

		// draw lightness gradient over the top
		const lightnessGradient = this.ctx.createLinearGradient(
			0, m.topY,
			0, m.bottomY
		);
		lightnessGradient.addColorStop(0, 'black');
		lightnessGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
		fillTriangle(lightnessGradient);

		// draw indicator

		let ix = m.leftX + this.point.x * m.triangleSideLength,
			iy = m.topY + this.point.y * (1.5 * m.triangleRadius);

		this.ctx.strokeStyle = 'white';
		this.ctx.beginPath();
		this.ctx.arc(ix, iy, 4, 0, 2 * Math.PI);
		this.ctx.stroke();
		this.ctx.strokeStyle = 'black';
		this.ctx.beginPath();
		this.ctx.arc(ix, iy, 5, 0, 2 * Math.PI);
		this.ctx.stroke();

		this.updateImageDataCache();
	}

	this.update = () => {
		if (this.dragging === 'hue') {
			let x = this.mouse.x - this.canvas.width / 2,
				y = this.mouse.y - this.canvas.height / 2;

			this.hue = Math.atan2(y, x) * 180 / Math.PI;
			if (this.hue < 0)
				this.hue += 360;

			this.draw();

		} else if (this.dragging === 'triangle') {

			let m = this.getMeasurements();

			if (this.mouseInsideTriangle()) {
				this.point.x = (this.mouse.x - m.leftX) / m.triangleSideLength;
				this.point.y = (this.mouse.y - m.topY) / (1.5 * m.triangleRadius);
			}

			this.drawTriangle();
		}

		this.selectedColour = this.getColour();
		this.onUpdate(this.selectedColour);
	}

	this.canvas.addEventListener('mousedown', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		let x = this.mouse.x - this.canvas.width / 2,
			y = this.mouse.y - this.canvas.height / 2,
			// distance from corner to center of triangle
			triangleRadius = Math.floor(Math.min(this.canvas.width, this.canvas.height) / 2) - this.hueCircleWidth;

		if (this.mouseInsideTriangle())
			this.dragging = 'triangle';
		else if (Math.hypot(x, y) > triangleRadius && Math.hypot(x, y) < triangleRadius + this.hueCircleWidth)
			this.dragging = 'hue';
		else
			this.dragging = 'none';

		if (this.dragging !== 'none')
			this.update();
	});
	this.canvas.addEventListener('mouseup', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		if (this.dragging !== 'none')
			this.update();

		this.dragging = 'none';
	});
	this.canvas.addEventListener('mousemove', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		if (this.dragging !== 'none')
			this.update();
	});

	// init
	this.draw();
	this.updateImageDataCache();
}
const picker = new ColourPicker(colour => {
	document.querySelector('span').style.backgroundColor = colour.toHslString();
}, 512, 512);
document.querySelector('.picker').appendChild(picker.canvas);
</script>
</body>
</html>