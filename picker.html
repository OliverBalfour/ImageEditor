<!DOCTYPE html>
<html>
<head>
	<title>Colour Picker 2.0</title>
	<meta charset="utf-8">
	<style type="text/css">canvas{border:1px solid black}</style>
</head>
<body>
<div class='picker'></div>
<span>Hello</span>
<script src='tinycolor/tinycolor.js'></script>
<script>
function ColourPicker (onUpdate, width, height) {
	this.canvas = document.createElement('canvas');
	this.ctx = this.canvas.getContext('2d');
	this.onUpdate = onUpdate;

	this.canvas.width = !isNaN(width) && width > 0 ? Math.round(width) : 128;
	this.canvas.height = !isNaN(height) && height > 0 ? Math.round(height) : this.canvas.width;

	this.hueCircleWidth = Math.min(this.canvas.width, this.canvas.height) / 8;

	this.mouse = { x: 0, y: 0 };
	// dragging: 'none', 'hue', or 'triangle'
	this.dragging = 'none';

	// hue, 0-360, on the hue circle
	this.hue = 0;
	// x,y point (0-1 scaled across width) on the saturation/lightness triangle
	// indicated by small black/white circle
	this.point = {x: 0.5, y: 0}
	this.selectedColour = tinycolor({h: 0, s: 0, l: 0, a: 0});

	this.imageDataCache = null;
	this.updateImageDataCache = () => {
		this.imageDataCache = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
	}
	this.updateImageDataCache();

	this.getColour = () => {
		let i = this.mouse.y * this.canvas.width + this.mouse.x;
		i *= 4;
		if (this.mouseInsideTriangle())
			return tinycolor({
				r: this.imageDataCache.data[i],
				g: this.imageDataCache.data[i + 1],
				b: this.imageDataCache.data[i + 2],
				a: this.imageDataCache.data[i + 3]
			});
		else
			return tinycolor({h: 0, s: 0, l: 0, a: 0});
	}

	this.updateMouseCoords = event => {
		this.box = this.canvas.getBoundingClientRect();
		this.mouse.x = event.clientX - this.box.left;
		this.mouse.y = event.clientY - this.box.top;
	}

	this.mouseInsideTriangle = () => {
		let w = this.canvas.width,
			h = this.canvas.height,
			min = Math.min(w, h),
			max = Math.max(w, h),
			mx = h < w ? Math.floor((max - min) / 2) : 0,
			my = w < h ? Math.floor((max - min) / 2) : 0;

		let triangleRadius = Math.floor(min / 2) - this.hueCircleWidth;

		let leftX = w / 2 - Math.sqrt(3)/2 * triangleRadius,
			rightX = w / 2 + Math.sqrt(3)/2 * triangleRadius,
			topY = my + this.hueCircleWidth,
			bottomY = (h + triangleRadius) / 2;

		// if mouse is below bottom of triangle, or too far left or right to possibly collide
		// ie bounding box collision detection
		if (
			this.mouse.y > bottomY ||
			this.mouse.x < leftX ||
			this.mouse.x > rightX ||
			this.mouse.y < topY
		)
			return false;

		// if the angle from the right bottom corner to the mouse is > 60 degrees
		if (Math.atan(
			(this.mouse.y - bottomY)
			/ (this.mouse.x - rightX)
		) / Math.PI * 180 > 60)
			return false;

		// if the angle from the left bottom corner to the mouse is > 60 degrees
		if (Math.atan(
			(this.mouse.y - bottomY)
			/ (this.mouse.x - leftX)
		) / Math.PI * 180 < -60)
			return false;

		return true;
	}

	this.draw = () => {
		this.drawCircle();
		this.drawTriangle();
	}

	this.drawCircle = () => {
		let w = this.canvas.width,
			h = this.canvas.height,
			// smaller and larger dimension
			min = Math.min(w, h),
			max = Math.max(w, h),
			// margin on either side of colour picker
			mx = h < w ? Math.floor((max - min) / 2) : 0,
			my = w < h ? Math.floor((max - min) / 2) : 0,
			segments = max * 4;

		this.ctx.save();
		this.ctx.lineWidth = this.hueCircleWidth;

		for (let i = 0; i <= 2 * Math.PI; i += Math.PI / segments) {
			this.ctx.strokeStyle = tinycolor({ h: i / Math.PI * 180, s: 100, l: 50 }).toHslString();
			this.ctx.beginPath();
			this.ctx.arc(
				Math.floor(w / 2), Math.floor(h / 2),
				Math.floor(min / 2) - this.hueCircleWidth / 2,
				i, i + Math.PI / segments + 0.05
			);
			this.ctx.stroke();
			this.ctx.closePath();
		}

		this.updateImageDataCache();
	}

	this.drawTriangle = () => {
		let w = this.canvas.width,
			h = this.canvas.height,
			// smaller and larger dimension
			min = Math.min(w, h),
			max = Math.max(w, h),
			// margin on either side of colour picker
			mx = h < w ? Math.floor((max - min) / 2) : 0,
			my = w < h ? Math.floor((max - min) / 2) : 0;

		// distance from corner to center of triangle
		// not technically a radius, there's another word for it which I've forgotten
		let triangleRadius = Math.floor(min / 2) - this.hueCircleWidth;

		const fillTriangle = fill => {
			this.ctx.fillStyle = fill;
			this.ctx.beginPath();
			this.ctx.moveTo(w / 2, my + this.hueCircleWidth);
			// sqrt(3) / 2 * radius is half the side length of the triangle
			this.ctx.lineTo(w / 2 + Math.sqrt(3)/2 * triangleRadius, h / 2 + triangleRadius / 2);
			this.ctx.lineTo(w / 2 - Math.sqrt(3)/2 * triangleRadius, h / 2 + triangleRadius / 2);
			this.ctx.fill();
			this.ctx.closePath();
		}

		// clear old triangle
		this.ctx.fillStyle = '#ccc';
		this.ctx.beginPath();
		this.ctx.arc(w / 2, h / 2, Math.floor(min / 2) - this.hueCircleWidth, 0, Math.PI * 2);
		this.ctx.fill();
		this.ctx.closePath();

		const saturationGradient = this.ctx.createLinearGradient(
			w / 2 - Math.sqrt(3)/2 * triangleRadius, 0,
			w / 2 + Math.sqrt(3)/2 * triangleRadius, 0
		);
		saturationGradient.addColorStop(0, 'white');
		saturationGradient.addColorStop(1, tinycolor({ h: this.hue, s: 100, l: 50 }).toHslString());
		fillTriangle(saturationGradient);

		const lightnessGradient = this.ctx.createLinearGradient(
			0, this.hueCircleWidth,
			0, h / 2 + triangleRadius / 2
		);
		lightnessGradient.addColorStop(0, 'black');
		lightnessGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
		fillTriangle(lightnessGradient);

		this.updateImageDataCache();
	}

	this.update = () => {
		if (this.dragging === 'hue') {
			let x = this.mouse.x - this.canvas.width / 2,
				y = this.mouse.y - this.canvas.height / 2;
			this.hue = Math.atan2(y, x) * 180 / Math.PI;
			if (this.hue < 0)
				this.hue += 360;
			this.draw();
		} else if (this.dragging === 'triangle') {
			this.drawTriangle();
		}

		this.selectedColour = this.getColour();
		this.onUpdate(this.selectedColour);
	}

	this.canvas.addEventListener('mousedown', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		let colour = this.getColour();

		let x = this.mouse.x - this.canvas.width / 2,
			y = this.mouse.y - this.canvas.height / 2,
			// distance from corner to center of triangle
			triangleRadius = Math.floor(Math.min(this.canvas.width, this.canvas.height) / 2) - this.hueCircleWidth;

		if (this.mouseInsideTriangle())
			this.dragging = 'triangle';
		else if (Math.hypot(x, y) > triangleRadius && Math.hypot(x, y) < triangleRadius + this.hueCircleWidth)
			this.dragging = 'hue';
		else
			this.dragging = 'none';

		if (this.dragging !== 'none')
			this.update();
	});
	this.canvas.addEventListener('mouseup', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		if (this.dragging !== 'none')
			this.update();

		this.dragging = 'none';
	});
	this.canvas.addEventListener('mousemove', event => {
		this.updateMouseCoords(event);
		this.drawTriangle();

		if (this.dragging !== 'none')
			this.update();
	});
	this.draw();
}
const picker = new ColourPicker(colour => {
	document.querySelector('span').style.backgroundColor = colour.toHslString();
}, 512, 512);
document.querySelector('.picker').appendChild(picker.canvas);
</script>
</body>
</html>